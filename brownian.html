<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>随机过程：物理实验室与金融沙盘</title>
    <style>
        :root {
            --water-bg: #e0f2fe;
            --panel-bg: #ffffff;
            --text-main: #1e293b;
            --accent: #2563eb;
            --border: #cbd5e1;
        }

        body, html { margin: 0; padding: 0; background: #f1f5f9; font-family: "Segoe UI", Roboto, sans-serif; overflow-y: auto; }
        .container { display: flex; flex-direction: column; gap: 25px; padding: 30px 20px 150px; max-width: 1200px; margin: 0 auto; }
        
        .section-title { 
            font-size: 20px; font-weight: 700; color: #475569; 
            padding-left: 10px; border-left: 4px solid var(--accent); margin-bottom: 5px;
        }

        .row { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; height: 480px; }
        
        .panel { 
            background: var(--panel-bg); border-radius: 16px; border: 1px solid var(--border); 
            display: flex; flex-direction: column; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); overflow: hidden; 
        }

        .water-tank { background: var(--water-bg) !important; position: relative; }
        .water-tank::after {
            content: ""; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, transparent 50%);
            pointer-events: none;
        }

        .header { padding: 15px 20px; border-bottom: 1px solid #e2e8f0; background: rgba(255,255,255,0.8); z-index: 5; }
        h3 { margin: 0; font-size: 16px; color: var(--text-main); }
        .description { font-size: 12px; color: #64748b; margin-top: 5px; line-height: 1.4; }

        canvas { flex-grow: 1; width: 100%; height: 100%; display: block; }

        .controls-container { 
            position: fixed; bottom: 0; left: 0; right: 0; height: 130px; 
            background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(20px); 
            border-top: 1px solid var(--border); display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 1000;
        }
        .control-row { display: flex; align-items: center; justify-content: center; gap: 40px; width: 100%; max-width: 900px; padding: 5px 0; }
        .slider-group { display: flex; align-items: center; gap: 15px; flex-grow: 1; }
        input[type=range] { cursor: pointer; accent-color: var(--accent); flex-grow: 1; }
        .btn { 
            padding: 10px 24px; border-radius: 8px; border: 1px solid var(--accent); 
            background: white; color: var(--accent); cursor: pointer; font-size: 13px; font-weight: 600; 
            transition: 0.2s;
        }
        .btn:hover { background: var(--accent); color: white; transform: translateY(-1px); }
    </style>
</head>
<body>

<div class="container">
    <div class="section-title">微观视角：个体运动追踪</div>
    <div class="row">
        <div class="panel water-tank">
            <div class="header">
                <h3>单体墨水分子轨迹</h3>
                <div class="description">记录单个粒子在水分子撞击下的随机位移路径。</div>
            </div>
            <canvas id="c1"></canvas>
        </div>
        <div class="panel">
            <div class="header">
                <h3>单体资产价格演向</h3>
                <div class="description">模拟单一金融资产的随机行走波动。</div>
            </div>
            <canvas id="c2"></canvas>
        </div>
    </div>

    <div class="section-title">宏观视角：群体演化模拟</div>
    <div class="row">
        <div class="panel water-tank">
            <div class="header">
                <h3>一滴墨水的扩散形变</h3>
                <div class="description">观测大量微观粒子在液体中形成的宏观渗透效应。</div>
            </div>
            <canvas id="c3"></canvas>
        </div>
        <div class="panel">
            <div class="header">
                <h3>资产价格概率预测扇面</h3>
                <div class="description">基于蒙特卡洛算法的群体价格路径演化。</div>
            </div>
            <canvas id="c4"></canvas>
        </div>
    </div>
</div>

<div class="controls-container">
    <div class="control-row">
        <div class="slider-group">
            <span style="font-size:13px; font-weight:bold; min-width:80px;">环境波动率</span>
            <input type="range" id="volSlider" min="5" max="100" value="35">
        </div>
        <div style="display:flex; gap:12px;">
            <button class="btn" id="playPause">暂停/继续</button>
            <button class="btn" id="resetBtn" style="border-style: dashed;">重构实验宇宙</button>
        </div>
    </div>
    <div class="control-row" style="width:100%;">
        <span style="font-size:13px; font-weight:bold; min-width:80px;">实验进度轴</span>
        <input type="range" id="timeSlider" min="0" max="1000" value="0">
    </div>
</div>

<script>
    const volSlider = document.getElementById('volSlider');
    const timeSlider = document.getElementById('timeSlider');
    const playPause = document.getElementById('playPause');
    const resetBtn = document.getElementById('resetBtn');

    let state = { 
        vol: 0.35, tick: 0, w: 0, h: 0, padding: 60, isPlaying: true, startPrice: 100,
        yAxis: { single: {min: 0, max: 200}, macro: {min: 0, max: 200} }
    };
    const canvases = ['c1', 'c2', 'c3', 'c4'].map(id => ({ el: document.getElementById(id), ctx: document.getElementById(id).getContext('2d') }));

    let seeds = { single: [], singlePricePath: [], diffusion: [], monteCarlo: [] };

    function randG() {
        let u=0, v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function drawWaterEffect(ctx) {
        ctx.save();
        ctx.fillStyle = "#e0f2fe";
        ctx.fillRect(0, 0, state.w, state.h);
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 2;
        for(let i=0; i<3; i++) {
            ctx.beginPath();
            ctx.ellipse(state.w*0.3, state.h*0.4, 100+i*50, 60+i*30, Math.PI/6, 0, Math.PI*2);
            ctx.stroke();
        }
        ctx.restore();
    }

    function generateNewUniverse() {
        state.startPrice = 70 + Math.random() * 80;
        state.vol = volSlider.value / 100;
        const dailyVol = state.vol * 0.05;

        // 重新设置 tick
        state.tick = 0;
        timeSlider.value = 0;

        seeds.single = Array.from({length: 1200}, () => ({ dx: randG(), dy: randG(), r: randG() }));
        seeds.singlePricePath = [state.startPrice];
        let sMin = state.startPrice, sMax = state.startPrice;
        let sCur = state.startPrice;
        for(let i=0; i<1200; i++) {
            sCur *= Math.exp(seeds.single[i].r * dailyVol - 0.5 * dailyVol * dailyVol);
            seeds.singlePricePath.push(sCur);
            if(sCur < sMin) sMin = sCur; if(sCur > sMax) sMax = sCur;
        }
        const sMargin = (sMax - sMin) * 0.15;
        state.yAxis.single = { min: Math.max(0, sMin - sMargin), max: sMax + sMargin };

        let mMin = state.startPrice, mMax = state.startPrice;
        seeds.monteCarlo = Array.from({length: 65}, () => {
            let p = [state.startPrice], cur = state.startPrice;
            for(let i=0; i<1200; i++) { 
                cur *= Math.exp(randG() * dailyVol - 0.5 * dailyVol * dailyVol);
                p.push(cur);
                if(cur < mMin) mMin = cur; if(cur > mMax) mMax = cur;
            }
            return p;
        });
        const mMargin = (mMax - mMin) * 0.08;
        state.yAxis.macro = { min: Math.max(0, mMin - mMargin), max: mMax + mMargin };
        seeds.diffusion = Array.from({length: 1200}, () => ({ steps: Array.from({length: 1000}, () => ({x: randG(), y: randG()})) }));
    }

    function init() {
        state.w = canvases[0].el.offsetWidth; state.h = canvases[0].el.offsetHeight;
        // 关键：确保 slider 范围与画布宽度匹配
        timeSlider.max = Math.floor(state.w - state.padding * 2);
        canvases.forEach(c => { c.el.width = state.w; c.el.height = state.h; });
        generateNewUniverse();
    }

    function drawGrid(ctx, axisRange) {
        ctx.strokeStyle = "rgba(148, 163, 184, 0.1)"; ctx.lineWidth = 1;
        const range = axisRange.max - axisRange.min;
        for(let i=0; i<=6; i++) {
            let val = axisRange.max - (range * i / 6);
            let y = (state.h * 0.1) + (state.h * 0.8 * (i/6));
            ctx.beginPath(); ctx.moveTo(state.padding, y); ctx.lineTo(state.w, y); ctx.stroke();
            ctx.fillStyle = "#94a3b8"; ctx.font = "10px sans-serif";
            ctx.fillText(Math.max(0, val).toFixed(1), 12, y + 4);
        }
    }

    function renderAll() {
        const v = state.vol, t = Math.floor(state.tick);
        const getSingleY = (v) => (state.h * 0.1) + (state.h * 0.8) * (1 - (v - state.yAxis.single.min) / (state.yAxis.single.max - state.yAxis.single.min));
        const getMacroY = (v) => (state.h * 0.1) + (state.h * 0.8) * (1 - (v - state.yAxis.macro.min) / (state.yAxis.macro.max - state.yAxis.macro.min));

        canvases.forEach((c, i) => {
            c.ctx.clearRect(0,0, state.w, state.h);
            if(i === 0 || i === 2) drawWaterEffect(c.ctx);
        });

        const c1 = canvases[0];
        let ix = state.w/2, iy = state.h/2;
        c1.ctx.beginPath(); c1.ctx.strokeStyle = "rgba(30, 41, 59, 0.8)"; c1.ctx.lineWidth = 2;
        for(let i=0; i<t; i++) { ix += seeds.single[i].dx*v*12; iy += seeds.single[i].dy*v*12; c1.ctx.lineTo(ix, iy); }
        c1.ctx.stroke();

        drawGrid(canvases[1].ctx, state.yAxis.single);
        canvases[1].ctx.beginPath(); canvases[1].ctx.strokeStyle = "#2563eb"; canvases[1].ctx.lineWidth = 2.5;
        canvases[1].ctx.moveTo(state.padding, getSingleY(seeds.singlePricePath[0]));
        for(let i=0; i<t; i++) canvases[1].ctx.lineTo(state.padding+i, getSingleY(seeds.singlePricePath[i+1]));
        canvases[1].ctx.stroke();

        canvases[2].ctx.fillStyle = "rgba(15, 23, 42, 0.5)";
        seeds.diffusion.forEach(p => {
            let px = state.w/2, py = state.h/2;
            for(let i=0; i<t; i++) { px += p.steps[i].x*v*5; py += p.steps[i].y*v*5; }
            canvases[2].ctx.fillRect(px, py, 2.5, 2.5);
        });

        drawGrid(canvases[3].ctx, state.yAxis.macro);
        seeds.monteCarlo.forEach(path => {
            canvases[3].ctx.beginPath();
            canvases[3].ctx.strokeStyle = `rgba(37, 99, 235, ${0.03 + v*0.12})`;
            canvases[3].ctx.moveTo(state.padding, getMacroY(path[0]));
            for(let i=0; i<t; i+=2) canvases[3].ctx.lineTo(state.padding+i, getMacroY(path[i]));
            canvases[3].ctx.stroke();
        });
    }

    // 自动运行的核心循环
    function loop() {
        if(state.isPlaying) { 
            // 每次循环增加 tick 值
            state.tick += 1.3; 
            
            // 检查是否触底，触底自动重置
            if(state.tick > parseInt(timeSlider.max)) { 
                generateNewUniverse(); 
            }
            
            // 关键：强制同步滑动条数值，确保它看起来在动
            timeSlider.value = state.tick; 
            renderAll(); 
        }
        requestAnimationFrame(loop);
    }

    volSlider.oninput = (e) => { state.vol = e.target.value / 100; renderAll(); };
    
    // 手动拖拽进度条时，更新 state.tick
    timeSlider.oninput = (e) => { 
        state.tick = parseFloat(e.target.value); 
        renderAll(); 
    };

    playPause.onclick = () => { 
        state.isPlaying = !state.isPlaying; 
        playPause.innerText = state.isPlaying ? "暂停模拟" : "继续模拟"; 
    };
    
    resetBtn.onclick = generateNewUniverse;

    window.addEventListener('resize', init); 
    init(); 
    loop(); // 启动主循环
</script>
</body>
</html>