<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>末日堡垒 v7.2 - 物理修复</title>
    <style>
        body { margin: 0; overflow: hidden; background: #010101; color: #fff; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .top-bar { display: flex; justify-content: space-between; padding: 15px; }
        .hud-box { background: rgba(0,30,50,0.7); padding: 10px 20px; border-radius: 12px; border: 2px solid #00cec9; font-family: monospace; font-size: 20px; box-shadow: 0 0 10px rgba(0,206,201,0.2); }
        #timer { color: #ffeaa7; font-size: 28px; border-color: #fdcb6e; }
        #boss-hud { position: absolute; top: 90px; left: 50%; transform: translateX(-50%); width: 70%; display: none; }
        .boss-name { text-align: center; color: #a29bfe; font-weight: bold; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 3px; }
        .boss-hp-track { width: 100%; height: 12px; background: #111; border: 1px solid #fff; border-radius: 6px; overflow: hidden; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #6c5ce7, #d63031); transition: width 0.3s; }
        .bottom-bar { position: absolute; bottom: 25px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: flex-end; }
        #weapon-btns { pointer-events: auto; display: flex; gap: 12px; }
        .wp-btn { width: 60px; height: 60px; background: rgba(0,0,0,0.85); border: 2px solid #555; color: #fff; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 24px; cursor: pointer; transition: 0.3s; }
        .wp-btn.active { border-color: #00cec9; background: rgba(0,206,201,0.2); box-shadow: 0 0 20px #00cec9; transform: translateY(-5px); }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.96); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 100; }
        .lvl-grid { display: flex; gap: 20px; margin-top: 30px; }
        .lvl-card { background: rgba(255,255,255,0.05); border: 2px solid #444; padding: 25px; border-radius: 15px; text-align: center; cursor: pointer; width: 120px; transition: 0.3s; }
        .lvl-card:hover { border-color: #00cec9; transform: scale(1.05); }
        .btn-restart { background: #00cec9; border: none; color: #000; padding: 15px 40px; font-size: 20px; border-radius: 10px; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="hud-box" id="lvl-txt">STAGE 1</div>
            <div class="hud-box" id="timer">03:00</div>
            <div class="hud-box" id="score-txt">0</div>
        </div>
        <div id="boss-hud"><div class="boss-name" id="boss-name">BOSS</div><div class="boss-hp-track"><div id="boss-hp-fill"></div></div></div>
        <div class="bottom-bar">
            <div class="hud-box" style="color:#55efc4; border-color:#55efc4">SHIELD: <span id="hp-txt">300</span></div>
            <div id="weapon-btns">
                <div class="wp-btn active" onclick="setWp(0)">1</div>
                <div class="wp-btn" onclick="setWp(1)">2</div>
                <div class="wp-btn" onclick="setWp(2)">3</div>
                <div class="wp-btn" onclick="setWp(3)">4</div>
            </div>
        </div>
    </div>

    <div id="start-screen" class="overlay">
        <h1 style="color:#00cec9; font-size:40px; text-shadow:0 0 20px #00cec9;">NEON DEFENSE v7.2</h1>
        <p style="color:#888;">修正敌人穿墙BUG | 降低AI难度</p>
        <div class="lvl-grid">
            <div class="lvl-card" onclick="initGame(0)"><h2>EASY</h2></div>
            <div class="lvl-card" onclick="initGame(1)"><h2>MED</h2></div>
            <div class="lvl-card" onclick="initGame(2)"><h2 style="color:#ff7675">HARD</h2></div>
        </div>
    </div>

    <div id="msg-screen" class="overlay" style="display:none;">
        <h1 id="msg-title">MISSION COMPLETE</h1>
        <button class="btn-restart" onclick="location.reload()">返回总部</button>
    </div>

    <canvas id="game"></canvas>

<script>
/** 音频系统 **/
const AudioSys = {
    ctx: null,
    init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === 'suspended') this.ctx.resume(); },
    play(f, t, d, v = 0.1, r = 1) {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = t; o.frequency.setValueAtTime(f, this.ctx.currentTime);
        if (r !== 1) o.frequency.exponentialRampToValueAtTime(f * r, this.ctx.currentTime + d);
        g.gain.setValueAtTime(v, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + d);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime + d);
    }
};

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W, H, gameActive = false;

const WEAPONS = [
    { name: "PULSE", rate: 110, dmg: 30, color: '#f1c40f', speed: 18, snd:()=>AudioSys.play(400, 'triangle', 0.1, 0.1) },
    { name: "SHOTGUN", rate: 450, dmg: 16, count: 10, color: '#e67e22', speed: 14, snd:()=>AudioSys.play(150, 'sawtooth', 0.2, 0.15) },
    { name: "RAPID", rate: 50, dmg: 12, color: '#00cec9', speed: 20, snd:()=>AudioSys.play(800, 'square', 0.05, 0.04) },
    { name: "OMEGA", rate: 900, dmg: 300, color: '#a29bfe', speed: 38, rail: true, snd:()=>AudioSys.play(60, 'sawtooth', 0.6, 0.2) }
];

const BOSS_CONF = [
    { name: "THE SQUARE SENTINEL", sides: 4, star: false, hp: 3000 },
    { name: "HEXAGON OVERLORD", sides: 6, star: false, hp: 7000 },
    { name: "VOID SINGULARITY", sides: 15, star: true, hp: 12000 }
];

let state = {
    lvl: 0, time: 180, score: 0,
    player: { x:0, y:0, hp:300, maxHp:300, wp:0, ang:0, lastF:0 },
    enemies: [], bullets: [], obstacles: [], boss: null
};

function resize() { W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight; }
window.onresize = resize; resize();

function setWp(i) { AudioSys.init(); state.player.wp = i; AudioSys.play(1000, 'sine', 0.05, 0.05); document.querySelectorAll('.wp-btn').forEach((btn, idx) => btn.className = idx===i ? 'wp-btn active' : 'wp-btn'); }

/** 碰撞逻辑的核心修复 **/
function checkCollision(x, y, size) {
    for (let ob of state.obstacles) {
        if (x + size > ob.x && x - size < ob.x + ob.w && y + size > ob.y && y - size < ob.y + ob.h) return true;
    }
    return false;
}

function initGame(lvl) {
    AudioSys.init();
    document.getElementById('start-screen').style.display = 'none';
    state.lvl = lvl; state.time = 180; state.score = 0;
    state.player.x = W/2; state.player.y = H/2; state.player.hp = 300;
    state.enemies = []; state.bullets = []; state.boss = null;
    state.obstacles = [];
    const obsCount = 8 - lvl * 2;
    for(let i=0; i<obsCount; i++) {
        state.obstacles.push({ x: 150 + Math.random() * (W-300), y: 150 + Math.random() * (H-300), w: 60 + Math.random() * 80, h: 60 + Math.random() * 80 });
    }
    document.getElementById('lvl-txt').innerText = `STAGE ${lvl+1}`;
    gameActive = true;
    requestAnimationFrame(loop);
}

function update(dt) {
    if(!gameActive) return;

    if(!state.boss) {
        state.time -= dt;
        if(state.time <= 0) { spawnBoss(); }
    }
    const m = Math.floor(state.time/60), s = Math.floor(state.time%60);
    document.getElementById('timer').innerText = `${m}:${s<10?'0'+s:s}`;

    // 玩家移动 (带墙壁阻挡)
    let mx=0, my=0;
    if(keys['w']) my=-1; if(keys['s']) my=1; if(keys['a']) mx=-1; if(keys['d']) mx=1;
    if(touch.lActive) { mx=touch.lVec.x; my=touch.lVec.y; }
    
    let nextX = state.player.x + mx * 7;
    let nextY = state.player.y + my * 7;
    if (!checkCollision(nextX, state.player.y, 15)) state.player.x = Math.max(20, Math.min(W-20, nextX));
    if (!checkCollision(state.player.x, nextY, 15)) state.player.y = Math.max(20, Math.min(H-20, nextY));

    // 自动回血
    state.player.hp = Math.min(300, state.player.hp + (mx===0 && my===0 ? 0.25 : 0.1));

    // 射击逻辑
    if(touch.rActive) state.player.ang = Math.atan2(touch.rVec.y, touch.rVec.x);
    else state.player.ang = Math.atan2(mouse.y - state.player.y, mouse.x - state.player.x);

    const wp = WEAPONS[state.player.wp];
    if((mouse.down || (touch.rActive && (Math.abs(touch.rVec.x)>0.1 || Math.abs(touch.rVec.y)>0.1))) && Date.now() - state.player.lastF > wp.rate) {
        wp.snd();
        const shoot = (a) => state.bullets.push({ x:state.player.x, y:state.player.y, vx:Math.cos(a)*wp.speed, vy:Math.sin(a)*wp.speed, dmg:wp.dmg, color:wp.color, rail:wp.rail, p:true });
        if(wp.count) { for(let i=0; i<wp.count; i++) shoot(state.player.ang + (Math.random()-0.5)*0.6); }
        else shoot(state.player.ang);
        state.player.lastF = Date.now();
    }

    // 敌人平衡性调整 (数量变少, 速度变慢)
    let spawnRate = 0.02 + state.lvl * 0.015; 
    if(!state.boss && Math.random() < spawnRate) {
        const side = Math.floor(Math.random()*4);
        let ex, ey;
        if(side==0){ex=Math.random()*W; ey=-50;} else if(side==1){ex=Math.random()*W; ey=H+50;}
        else if(side==2){ex=-50; ey=Math.random()*H;} else {ex=W+50; ey=Math.random()*H;}
        state.enemies.push({ x:ex, y:ey, hp:20+state.lvl*40, size:18, speed:1.2+state.lvl*0.6, color:'#ff7675' });
    }

    state.enemies.forEach((en, ei) => {
        let dx = state.player.x - en.x, dy = state.player.y - en.y, dist = Math.hypot(dx,dy);
        if(en === state.boss) {
            en.ang += 0.015; if(en.y < 150) en.y += 2;
            if(Date.now() - en.lastAtk > 1800 - state.lvl*200) {
                const bCount = 6 + state.lvl * 6;
                for(let i=0; i<bCount; i++) {
                    let a = (Math.PI*2/bCount)*i + en.ang;
                    state.bullets.push({ x:en.x, y:en.y, vx:Math.cos(a)*4, vy:Math.sin(a)*4, dmg:20, color:'#a29bfe', p:false });
                }
                en.lastAtk = Date.now();
            }
        } else {
            // 敌人避开掩体逻辑 (核心修复)
            let vx = (dx/dist) * en.speed;
            let vy = (dy/dist) * en.speed;
            if (!checkCollision(en.x + vx, en.y, en.size)) en.x += vx;
            if (!checkCollision(en.x, en.y + vy, en.size)) en.y += vy;
        }
        if(dist < en.size + 15) state.player.hp -= 0.4;
    });

    state.bullets.forEach((b, bi) => {
        b.x += b.vx; b.y += b.vy;
        state.obstacles.forEach(ob => {
            if(b.x > ob.x && b.x < ob.x+ob.w && b.y > ob.y && b.y < ob.y+ob.h) state.bullets.splice(bi, 1);
        });
        if(b.p) {
            state.enemies.forEach((en, ei) => {
                if(Math.hypot(b.x-en.x, b.y-en.y) < en.size + 15) {
                    en.hp -= b.dmg;
                    if(!b.rail) state.bullets.splice(bi,1);
                    if(en.hp <= 0) {
                        AudioSys.play(80, 'sawtooth', 0.2, 0.1);
                        if(en === state.boss) { gameActive = false; document.getElementById('msg-screen').style.display='flex'; }
                        else { state.enemies.splice(ei,1); state.score += 50; }
                    }
                }
            });
        } else if(Math.hypot(b.x-state.player.x, b.y-state.player.y) < 20) {
            state.player.hp -= b.dmg; state.bullets.splice(bi,1);
            AudioSys.play(150, 'square', 0.1, 0.2);
        }
    });

    document.getElementById('hp-txt').innerText = Math.ceil(state.player.hp);
    document.getElementById('score-txt').innerText = state.score;
    if(state.boss) document.getElementById('boss-hp-fill').style.width = (state.boss.hp/state.boss.maxHp*100) + "%";
    if(state.player.hp <= 0) { gameActive = false; document.getElementById('msg-title').innerText = "FAILED"; document.getElementById('msg-screen').style.display = 'flex'; }
}

function spawnBoss() {
    const data = BOSS_CONF[state.lvl];
    state.boss = { name: data.name, x: W/2, y: -200, hp: data.hp, maxHp: data.hp, size: 70, ang: 0, sides: data.sides, isStar: data.isStar, lastAtk: 0 };
    state.enemies = [state.boss];
    document.getElementById('boss-hud').style.display = 'block';
    document.getElementById('boss-name').innerText = data.name;
    AudioSys.play(60, 'sawtooth', 1.5, 0.2);
}

function draw() {
    ctx.fillStyle = '#010101'; ctx.fillRect(0,0,W,H);
    state.obstacles.forEach(ob => {
        ctx.fillStyle = 'rgba(0, 206, 201, 0.15)'; ctx.strokeStyle = '#00cec9'; ctx.lineWidth = 2;
        ctx.strokeRect(ob.x, ob.y, ob.w, ob.h); ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
    });
    ctx.save(); ctx.translate(state.player.x, state.player.y); ctx.rotate(state.player.ang);
    ctx.fillStyle = '#00cec9'; ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.fillRect(14,-4,16,8); ctx.restore();
    state.enemies.forEach(en => {
        ctx.save(); ctx.translate(en.x, en.y); ctx.rotate(en.ang || 0);
        ctx.fillStyle = (en === state.boss) ? '#ff7675' : '#d63031';
        if(en === state.boss) {
            const s = en.isStar ? 2 : 1; ctx.beginPath();
            for(let i=0; i<en.sides*s; i++) {
                let r = (en.isStar && i%2==0) ? en.size/2 : en.size;
                let a = (Math.PI*2/(en.sides*s))*i; ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
            }
            ctx.closePath(); ctx.fill(); ctx.stroke();
        } else { ctx.beginPath(); ctx.moveTo(en.size, 0); ctx.lineTo(-en.size, en.size); ctx.lineTo(-en.size, -en.size); ctx.closePath(); ctx.fill(); }
        ctx.restore();
    });
    state.bullets.forEach(b => { ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, b.rail?6:4, 0, Math.PI*2); ctx.fill(); });
    if(touch.lActive) {
        ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.arc(touch.lStart.x, touch.lStart.y, 60, 0, Math.PI*2); ctx.stroke();
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.beginPath(); ctx.arc(touch.lStart.x+touch.lVec.x*60, touch.lStart.y+touch.lVec.y*60, 25, 0, Math.PI*2); ctx.fill();
    }
}

/** 输入控制 (已优化) **/
const keys = {}, mouse = {x:0, y:0, down:false}, touch = {lActive:false, rActive:false, lStart:{x:0,y:0}, rStart:{x:0,y:0}, lVec:{x:0,y:0}, rVec:{x:0,y:0}, lID:null, rID:null};
window.onmousemove = e => { mouse.x=e.clientX; mouse.y=e.clientY; };
window.onmousedown = () => { AudioSys.init(); mouse.down = true; };
window.onmouseup = () => mouse.down = false;
window.onkeydown = e => { keys[e.key.toLowerCase()] = true; if(e.key >= '1' && e.key <= '4') setWp(parseInt(e.key)-1); };
window.onkeyup = e => keys[e.key.toLowerCase()] = false;
canvas.addEventListener('touchstart', e => {
    e.preventDefault(); AudioSys.init();
    for(let t of e.changedTouches) {
        if(t.clientX < W/2) { touch.lActive=true; touch.lStart={x:t.clientX, y:t.clientY}; touch.lID=t.identifier; }
        else { touch.rActive=true; touch.rStart={x:t.clientX, y:t.clientY}; touch.rID=t.identifier; }
    }
}, {passive:false});
canvas.addEventListener('touchmove', e => {
    for(let t of e.changedTouches) {
        if(t.identifier === touch.lID) { let dx=t.clientX-touch.lStart.x, dy=t.clientY-touch.lStart.y, d=Math.max(0.1,Math.hypot(dx,dy)); touch.lVec={x:dx/d*Math.min(1,d/60), y:dy/d*Math.min(1,d/60)}; }
        if(t.identifier === touch.rID) { let dx=t.clientX-touch.rStart.x, dy=t.clientY-touch.rStart.y, d=Math.max(0.1,Math.hypot(dx,dy)); touch.rVec={x:dx/d*Math.min(1,d/60), y:dy/d*Math.min(1,d/60)}; }
    }
}, {passive:false});
canvas.addEventListener('touchend', e => {
    for(let t of e.changedTouches) {
        if(t.identifier === touch.lID) { touch.lActive=false; touch.lVec={x:0,y:0}; }
        if(t.identifier === touch.rID) { touch.rActive=false; touch.rVec={x:0,y:0}; }
    }
});
function loop() { update(0.016); draw(); if(gameActive) requestAnimationFrame(loop); }
</script>
</body>
</html>