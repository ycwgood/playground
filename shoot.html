<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>飞行躲避射击 - 纵向卷轴射击</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Arial', sans-serif; touch-action: none; }
        canvas { display: block; background: linear-gradient(180deg, #4A90E2 0%, #2E5C8A 100%); }
        #ui { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 1px 1px 2px #000; pointer-events: none; font-size: 1.1em; font-weight: bold; }
        #healthBar { display:inline-block; vertical-align: middle; width:150px; height:16px; background: rgba(0,0,0,0.4); border-radius:8px; margin-left:8px; overflow:hidden; box-shadow: inset 0 0 6px rgba(0,0,0,0.5); }
        #healthFill { height:100%; width:100%; background: linear-gradient(90deg,#32cd32,#ffcc00); transition: width 80ms linear; }
        #gameover { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; font-size: 2.5em; display: none; background: rgba(0,0,0,0.8); padding: 40px; border-radius: 12px; z-index: 100; }
        button { padding: 12px 20px; font-size: 16px; background: #ff4757; color: white; border: none; border-radius: 6px; margin-top: 20px; cursor: pointer; }
        .weapon-info { position: absolute; bottom: 20px; left: 20px; color: white; text-shadow: 1px 1px 2px #000; font-size: 1em; pointer-events: none; }
    </style>
</head>
<body>

<div id="ui">
    <div>生命: <div id="healthBar"><div id="healthFill"></div></div></div>
    <div>分数: <span id="score">0</span></div>
    <div>高度: <span id="height">0</span>m</div>
</div>

<div class="weapon-info">
    武器: <span id="weaponType">普通弹</span> | 等级: <span id="weaponLevel">Lv1</span>
</div>

<div id="gameover">
    <h1>游戏结束!</h1>
    <div style="font-size:0.6em;margin-top:10px;">最终分数: <span id="finalScore">0</span></div>
    <button onclick="resetGame()">重新开始</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// ========== 游戏状态 ==========
let gameState = {
    isGameOver: false,
    score: 0,
    scrollY: 0,  // 地图向下滚动的偏移
    frameCount: 0
};

// ========== 音效系统 ==========
const audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
let audioEnabled = true;
function ensureAudioRunning() { if (audioCtx?.state === 'suspended') audioCtx.resume().catch(() => {}); }
function playSound(type, freq = 400, duration = 0.15) {
    if (!audioCtx || !audioEnabled) return;
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.type = 'sine'; o.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(0.15, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + duration);
    o.start(now); o.stop(now + duration);
}
window.addEventListener('touchstart', ensureAudioRunning, { once: true, passive: true });
window.addEventListener('mousedown', ensureAudioRunning, { once: true });

// ========== 玩家飞机 ==========
let player = {
    x: canvas.width / 2,
    y: canvas.height - 80,
    r: 12,
    width: 24,
    height: 28,
    health: 100,
    maxHealth: 100,
    vx: 0,
    vy: 0,
    maxSpeed: 4,
    shootCooldown: 0,
    maxShootCooldown: 8,
    weaponType: 'normal', // normal, spread, bomb, missile, spin
    weaponLevel: 1
};

// ========== 摇杆状态 ==========
let moveJoystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, radius: 60, id: -1 };
let shootJoystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, radius: 60, id: -1 };

// ========== 游戏对象数组 ==========
let playerBullets = [];
let enemies = [];
let enemyBullets = [];
let items = [];
let groundTanks = [];
let particles = [];

// ========== 敌人类型定义 ==========
const ENEMY_TYPES = {
    scout: { health: 30, speed: 2, fireRate: 60, width: 16, height: 14, color: '#FF6B6B', sprite: 'scout' },
    fighter: { health: 50, speed: 2.5, fireRate: 40, width: 18, height: 20, color: '#FF8C42', sprite: 'fighter' },
    bomber: { health: 80, speed: 1.5, fireRate: 80, width: 24, height: 22, color: '#DC143C', sprite: 'bomber' },
    interceptor: { health: 40, speed: 3.5, fireRate: 30, width: 14, height: 16, color: '#FFD700', sprite: 'interceptor' }
};

// ========== 敌人飞机类 ==========
class Enemy {
    constructor(x, y, type = 'scout') {
        this.x = x;
        this.y = y;
        this.type = type;
        const cfg = ENEMY_TYPES[type];
        this.health = cfg.health;
        this.maxHealth = cfg.health;
        this.speed = cfg.speed;
        this.fireRate = cfg.fireRate;
        this.fireCounter = Math.random() * cfg.fireRate;
        this.width = cfg.width;
        this.height = cfg.height;
        this.color = cfg.color;
        this.vx = (Math.random() - 0.5) * 3;  // 左右波动
        this.wavePhase = Math.random() * Math.PI * 2;
    }

    update() {
        this.wavePhase += 0.02;
        this.x += this.vx;
        this.x = Math.max(this.width / 2, Math.min(canvas.width - this.width / 2, this.x));
        this.y += 2;  // 固定向下移动速度

        this.fireCounter++;
        if (this.fireCounter > this.fireRate) {
            this.shoot();
            this.fireCounter = 0;
        }
    }

    shoot() {
        playSound('hit', 300, 0.08);
        enemyBullets.push(new EnemyBullet(this.x, this.y + this.height / 2, Math.random() - 0.5, 3));
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        // 飞机主体（朝下）
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(0, this.height / 2);     // 底部指向
        ctx.lineTo(this.width / 2, -this.height / 2);
        ctx.lineTo(0, -this.height / 3);
        ctx.lineTo(-this.width / 2, -this.height / 2);
        ctx.closePath();
        ctx.fill();
        // 机翼加强
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-this.width / 2, -this.height / 2);
        ctx.lineTo(this.width / 2, -this.height / 2);
        ctx.stroke();
        // 血条
        ctx.fillStyle = 'red';
        ctx.fillRect(-this.width / 2, -this.height / 2 - 8, this.width, 3);
        ctx.fillStyle = 'lime';
        ctx.fillRect(-this.width / 2, -this.height / 2 - 8, (this.health / this.maxHealth) * this.width, 3);
        ctx.restore();
    }
}

// ========== 玩家子弹类 ==========
class PlayerBullet {
    constructor(x, y, vx, vy, type = 'normal') {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.r = 3;
        this.type = type;
        this.damage = { normal: 10, spread: 8, bomb: 25, missile: 20, spin: 12 }[type];
        this.lifetime = 300;
        this.color = { normal: '#FFFF00', spread: '#FFCC00', bomb: '#FF4444', missile: '#00FFFF', spin: '#00FF88' }[type];
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.lifetime--;
    }

    draw() {
        ctx.fillStyle = this.color;
        if (this.type === 'spin') {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r * 1.5, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fill();
        }
        // 子弹边框
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + (this.type === 'spin' ? 1 : 0), 0, Math.PI * 2);
        ctx.stroke();
    }
}

// ========== 敌人子弹类 ==========
class EnemyBullet {
    constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.r = 3;
        this.lifetime = 300;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.lifetime--;
    }

    draw() {
        ctx.fillStyle = '#FF1493';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ========== 道具类 ==========
class Item {
    constructor(x, y, type = 'health') {
        this.x = x;
        this.y = y;
        this.type = type;  // health, spread, bomb, missile, spin
        this.r = 8;
        this.lifetime = 200;
        this.rotation = 0;
    }

    update() {
        this.lifetime--;
        this.rotation += 0.1;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        if (this.type === 'health') {
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(-this.r / 2, -this.r, this.r, this.r * 2);
            ctx.fillRect(-this.r, -this.r / 2, this.r * 2, this.r);
        } else {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(0, 0, this.r, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
}

// ========== 地面坦克类 ==========
class GroundTank {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 28;
        this.height = 18;
        this.color = '#556B2F';
    }

    update() {
        this.y += 1;  // 缓慢向下移动
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        // 坦克车体
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
        // 炮塔
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(0, 0, this.width / 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

// ========== 粒子类 ==========
class Particle {
    constructor(x, y, vx, vy, color, lifetime) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.lifetime = lifetime;
        this.maxLifetime = lifetime;
        this.r = 3;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1;  // 重力
        this.lifetime--;
    }

    draw() {
        const alpha = this.lifetime / this.maxLifetime;
        ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ========== 玩家发射 ==========
function playerShoot() {
    if (player.shootCooldown > 0) return;
    playSound('shoot', 800, 0.1);
    
    const types = ['normal', 'spread', 'bomb', 'missile', 'spin'];
    const weaponType = types[Math.min(player.weaponLevel - 1, 4)];
    
    if (weaponType === 'normal' || player.weaponType === 'normal') {
        playerBullets.push(new PlayerBullet(player.x, player.y - player.height / 2, 0, -8, 'normal'));
    } else if (weaponType === 'spread') {
        for (let angle of [-Math.PI / 6, 0, Math.PI / 6]) {
            playerBullets.push(new PlayerBullet(player.x + Math.sin(angle) * 8, player.y - player.height / 2, Math.sin(angle) * 2, -7, 'spread'));
        }
    } else if (weaponType === 'bomb') {
        playerBullets.push(new PlayerBullet(player.x, player.y - player.height / 2, 0, -6, 'bomb'));
    } else if (weaponType === 'missile') {
        playerBullets.push(new PlayerBullet(player.x - 6, player.y - player.height / 2, -1, -7, 'missile'));
        playerBullets.push(new PlayerBullet(player.x + 6, player.y - player.height / 2, 1, -7, 'missile'));
    } else if (weaponType === 'spin') {
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            playerBullets.push(new PlayerBullet(player.x, player.y, Math.cos(angle) * 4, Math.sin(angle) * 4, 'spin'));
        }
    }
    
    player.shootCooldown = player.maxShootCooldown;
}

// ========== 敌人生成 ==========
function spawnEnemy() {
    const types = Object.keys(ENEMY_TYPES);
    const type = types[Math.floor(Math.random() * types.length)];
    const x = Math.random() * (canvas.width - 40) + 20;
    const y = -50;  // 从屏幕顶部外侧生成
    enemies.push(new Enemy(x, y, type));
}

// ========== 地面坦克生成 ==========
function spawnTank() {
    const x = Math.random() * (canvas.width - 50) + 25;
    const y = canvas.height + 50;  // 从屏幕底部外侧生成
    groundTanks.push(new GroundTank(x, y));
}

// ========== 主游戏循环 ==========
function animate(timestamp) {
    if (gameState.isGameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    gameState.frameCount++;
    gameState.scrollY += 1.5;  // 持续向下滚动

    // ========== 玩家移动 ==========
    if (moveJoystick.active) {
        const dx = moveJoystick.currentX - moveJoystick.startX;
        const dy = moveJoystick.currentY - moveJoystick.startY;
        player.vx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, dx / 15));
        player.vy = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, dy / 15));
    } else {
        player.vx *= 0.9;
        player.vy *= 0.9;
    }
    player.x += player.vx;
    player.y += player.vy;
    player.x = Math.max(player.r + player.width / 2, Math.min(canvas.width - player.r - player.width / 2, player.x));
    player.y = Math.max(player.r + player.height / 2, Math.min(canvas.height - player.r - player.height / 2, player.y));

    // ========== 玩家射击 ==========
    if (shootJoystick.active) {
        playerShoot();
    }
    if (player.shootCooldown > 0) player.shootCooldown--;

    // ========== 敌人生成 ==========
    if (gameState.frameCount % 80 === 0) spawnEnemy();
    if (gameState.frameCount % 200 === 0) spawnTank();

    // ========== 更新玩家子弹 ==========
    playerBullets = playerBullets.filter(b => b.lifetime > 0 && b.y > -100);
    playerBullets.forEach(b => {
        b.update();
        b.draw();
    });

    // ========== 更新敌人子弹 ==========
    enemyBullets = enemyBullets.filter(b => b.lifetime > 0);
    enemyBullets.forEach(b => {
        b.update();
        b.draw();
    });

    // ========== 更新敌人 ==========
    enemies = enemies.filter(e => e.y < canvas.height + 100 && e.health > 0);
    enemies.forEach(e => {
        e.update();
        e.draw();

        // 敌人与玩家子弹碰撞
        playerBullets.forEach((bullet, idx) => {
            const dist = Math.hypot(e.x - bullet.x, e.y - bullet.y);
            if (dist < e.width / 2 + bullet.r) {
                e.health -= bullet.damage;
                if (bullet.type === 'bomb') {
                    // 轰炸弹溅射
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(bullet.x, bullet.y, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, 'rgb(255,100,0)', 30));
                    }
                }
                playerBullets.splice(idx, 1);
                playSound('hit', 600, 0.12);
                if (e.health <= 0) {
                    gameState.score += 10;
                    // 掉落道具
                    if (Math.random() < 0.3) items.push(new Item(e.x, e.y, Math.random() < 0.6 ? 'health' : ['spread', 'bomb', 'missile', 'spin'][Math.floor(Math.random() * 4)]));
                    // 爆炸效果
                    for (let i = 0; i < 12; i++) {
                        particles.push(new Particle(e.x, e.y, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, 'rgb(255,165,0)', 40));
                    }
                    playSound('enemyDie', 400, 0.15);
                }
            }
        });
    });

    // ========== 更新道具 ==========
    items = items.filter(i => i.lifetime > 0);
    items.forEach(i => {
        i.update();
        i.draw();

        // 玩家碰撞道具
        if (Math.hypot(player.x - i.x, player.y - i.y) < player.r + i.r) {
            if (i.type === 'health') {
                player.health = Math.min(player.maxHealth, player.health + 30);
                playSound('shoot', 1200, 0.1);
            } else {
                player.weaponType = i.type;
                player.weaponLevel = Math.min(5, player.weaponLevel + 1);
                playSound('shoot', 1000, 0.15);
            }
            items.splice(items.indexOf(i), 1);
        }
    });

    // ========== 更新地面坦克 ==========
    groundTanks = groundTanks.filter(t => t.y < canvas.height + 100);
    groundTanks.forEach(t => {
        t.update();
        t.draw();
    });

    // ========== 更新粒子 ==========
    particles = particles.filter(p => p.lifetime > 0);
    particles.forEach(p => {
        p.update();
        p.draw();
    });

    // ========== 敌人子弹与玩家碰撞 ==========
    enemyBullets = enemyBullets.filter(eb => {
        const dist = Math.hypot(player.x - eb.x, player.y - eb.y);
        if (dist < player.r + eb.r) {
            player.health -= 10;
            playSound('hit', 200, 0.15);
            for (let i = 0; i < 6; i++) {
                particles.push(new Particle(player.x, player.y, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, 'rgb(255,0,0)', 20));
            }
            if (player.health <= 0) {
                playSound('death', 100, 0.5);
                endGame();
            }
            return false;
        }
        return true;
    });

    // ========== 绘制玩家 ==========
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = '#00FFFF';
    // 玩家飞机（朝上）
    ctx.beginPath();
    ctx.moveTo(0, -player.height / 2);     // 顶部指向
    ctx.lineTo(player.width / 2, player.height / 2);
    ctx.lineTo(0, player.height / 3);
    ctx.lineTo(-player.width / 2, player.height / 2);
    ctx.closePath();
    ctx.fill();
    // 机翼边框
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-player.width / 2, player.height / 2);
    ctx.lineTo(player.width / 2, player.height / 2);
    ctx.stroke();
    // 炮口
    ctx.fillStyle = '#FFFF00';
    ctx.fillRect(-2, -player.height / 2 - 6, 4, 8);
    ctx.restore();

    // ========== 绘制虚拟摇杆 ==========
    drawJoystick(moveJoystick, canvas.width / 4, canvas.height - canvas.height / 4, '移动');
    drawJoystick(shootJoystick, canvas.width - canvas.width / 4, canvas.height - canvas.height / 4, '射击');

    // ========== 更新 UI ==========
    document.getElementById('score').innerText = gameState.score;
    document.getElementById('height').innerText = Math.floor(gameState.scrollY / 10);
    document.getElementById('weaponType').innerText = ['普通弹', '散弹', '轰炸弹', '导弹', '旋转弹'][Math.min(player.weaponLevel - 1, 4)];
    document.getElementById('weaponLevel').innerText = 'Lv' + Math.min(player.weaponLevel, 5);
    const healthFill = document.getElementById('healthFill');
    if (healthFill) {
        const pct = Math.max(0, Math.min(1, player.health / player.maxHealth));
        healthFill.style.width = (pct * 100) + '%';
        if (pct < 0.3) healthFill.style.background = 'linear-gradient(90deg,#ff4d4d,#ffcc00)';
        else healthFill.style.background = 'linear-gradient(90deg,#32cd32,#ffcc00)';
    }

    requestAnimationFrame(animate);
}

// ========== 摇杆绘制 ==========
function drawJoystick(joystick, baseX, baseY, label) {
    if (!joystick.active) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(baseX, baseY, joystick.radius, 0, Math.PI * 2);
        ctx.stroke();
        return;
    }
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(joystick.startX, joystick.startY, joystick.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.beginPath();
    ctx.arc(joystick.currentX, joystick.currentY, joystick.radius / 2, 0, Math.PI * 2);
    ctx.fill();
}

// ========== 触摸事件 ==========
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    for (let touch of e.touches) {
        if (touch.clientX < canvas.width / 2 && !moveJoystick.active) {
            moveJoystick.active = true;
            moveJoystick.startX = touch.clientX;
            moveJoystick.startY = touch.clientY;
            moveJoystick.currentX = touch.clientX;
            moveJoystick.currentY = touch.clientY;
            moveJoystick.id = touch.identifier;
        } else if (touch.clientX >= canvas.width / 2 && !shootJoystick.active) {
            shootJoystick.active = true;
            shootJoystick.startX = touch.clientX;
            shootJoystick.startY = touch.clientY;
            shootJoystick.currentX = touch.clientX;
            shootJoystick.currentY = touch.clientY;
            shootJoystick.id = touch.identifier;
        }
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (let touch of e.touches) {
        if (moveJoystick.active && touch.identifier === moveJoystick.id) {
            moveJoystick.currentX = touch.clientX;
            moveJoystick.currentY = touch.clientY;
        } else if (shootJoystick.active && touch.identifier === shootJoystick.id) {
            shootJoystick.currentX = touch.clientX;
            shootJoystick.currentY = touch.clientY;
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    for (let touch of e.changedTouches) {
        if (touch.identifier === moveJoystick.id) moveJoystick.active = false;
        if (touch.identifier === shootJoystick.id) shootJoystick.active = false;
    }
});

// ========== 鼠标支持 ==========
canvas.addEventListener('mousedown', (e) => {
    if (e.clientX < canvas.width / 2) {
        moveJoystick.active = true;
        moveJoystick.startX = e.clientX;
        moveJoystick.startY = e.clientY;
        moveJoystick.currentX = e.clientX;
        moveJoystick.currentY = e.clientY;
    } else {
        shootJoystick.active = true;
        shootJoystick.startX = e.clientX;
        shootJoystick.startY = e.clientY;
        shootJoystick.currentX = e.clientX;
        shootJoystick.currentY = e.clientY;
    }
});

canvas.addEventListener('mousemove', (e) => {
    if (moveJoystick.active) {
        moveJoystick.currentX = e.clientX;
        moveJoystick.currentY = e.clientY;
    }
    if (shootJoystick.active) {
        shootJoystick.currentX = e.clientX;
        shootJoystick.currentY = e.clientY;
    }
});

canvas.addEventListener('mouseup', () => {
    moveJoystick.active = false;
    shootJoystick.active = false;
});

// ========== 游戏结束 ==========
function endGame() {
    gameState.isGameOver = true;
    document.getElementById('finalScore').innerText = gameState.score;
    document.getElementById('gameover').style.display = 'block';
}

function resetGame() {
    location.reload();
}

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

// ========== 启动游戏 ==========
requestAnimationFrame(animate);
</script>

</body>
</html>
